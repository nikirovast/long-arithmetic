% Diese Zeile bitte -nicht- aendern.
\documentclass[course=erap]{aspdoc}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% TODO: Ersetzen Sie in den folgenden Zeilen die entsprechenden -Texte-
%% mit den richtigen Werten.
\newcommand{\theGroup}{147} % Beispiel: 42
\newcommand{\theNumber}{A326} % Beispiel: A123
\author{Yulia Nikirova \and Andriy Manucharyan}
\date{Sommersemester 2021} % Beispiel: Wintersemester 2019/20
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Diese Zeile bitte -nicht- aendern.
\title{Gruppe \theGroup{} -- Abgabe zu Aufgabe \theNumber}

\begin{document}
\maketitle

\section{Einleitung}
Die vorliegende Arbeit beschäftigt sich mit dem Algorithmus der schnellen Exponentiation von Matrizen von großen Zahlen und seine Anwendung auf die iterative Berechnung der Konstante  \(\sqrt{2}\) mit der beliebigen vom Benutzer wählbaren Genauigkeit. Zu diesem Zweck wurde eine Methode zur Speicherung langer Zahlen und zur effizienten Durchführung mathematischer Operationen auf diesen entwickelt und die Anzahl der Operationen, die zum Erreichen einer bestimmten Genauigkeit erforderlich sind, mathematisch abgeschätzt.
\section{Lösungsansatz}
\subsection{Überblick}%
Die iterative Formel, die wir zur Berechnung der Konstante \(\sqrt{2}\) verwenden, lautet wie folgt:
\begin{equation}\label{eq:iterativeSqrt2}
\lim_{n \to \infty} {1+\frac{x_n}{x_{n+1}}} = \sqrt{2} 
\end{equation}
Wobei die $x_n$ und $x_{n+1}$ Terme lassen sich durch die Exponentiation der Matrix
$\begin{pmatrix}
  0 & 1\\ 
  1 & 2
\end{pmatrix}$ bestimmen, das heißt:
\begin{equation}\label{eq:matrixPower}
{\begin{pmatrix}
x_{n-1} & x_n \\
x_n & x_{n+1}
\end{pmatrix} } =
{\begin{pmatrix}
0 & 1\\
1 & 2
\end{pmatrix} }^n
\end{equation}
Und um (\ref{eq:matrixPower}) zu berechnen, verwenden wir die schnelle Exponentiation, die im Folgenden im Detail erläutern wird.
\subsection{Warum die schnelle Exponentiation funktioniert}%
darum
\subsection{Die schnelle Exponentiation auf Matrizen}%
\subsection{Die Struktur, die uns erlaubt, die Zahlen mit beliebiger Genauigkeit zu speichern}%
Da unser Hauptinteresse darin besteht, die Konstante mit hoher Genauigkeit zu berechnen, müssen wir die Werte von $x_n$ und $x_{n+1}$ bei großem n berechnen, was bedeutet, dass diese Zahlen möglicherweise nicht in das \textit{long} Format des Computerprotokolls passen. Um dies zu tun, speichern wir sie als ein Array von vorzeichenlosen 32-Bit-Zahlen, die jeweils 32 Bits der binären Darstellung der Zahl enthalten. Um es bequemer zu machen, weitere Berechnungen durchzuführen, speichern wir unsere Zahl in einem Array von links nach rechts, d.h. das Null-Element des Arrays enthält die niedrigsten 32 Bits.\\
Wir wollen zum Beispiel die Zahl \textit{18446744073709558563} in unserer Struktur behalten. Die Darstellung im Binärsystem sieht wie folgt aus: \\
\centerline{\textit{1|000000000000000000000000000000|0000000000000000000001101100100011}}
Dann wird die in unserer Struktur wie folgt gespeichert:
\begin{equation*}
\begin{array}{|c|c|c|}\hline
array[0] & array[1] & array[2]\\
\hline
00000000000000000001101100100011 & 00000000000000000000000000000000 & 1 \\
\hline
\end{array}
\end{equation*}
\subsection{Addition und Multiplikation dieser Zahlen}%
\section{Genauigkeit}
Wie in der Einleitung oben erwähnt, gehen wir davon aus, dass der Benutzer über die Konsole eingeben kann, mit welcher Genauigkeit das Ergebnis ausgegeben werden sollte. Wir haben uns dafür entschieden, dass in unserem Fall die Anzahl der korrekten Nachkommastellen eine angemessene Genauigkeit ist. Daher werden wir im Folgenden die Argumentation für die Schätzung der Anzahl der Iterationen demonstrieren, die erforderlich sind, um eine bestimmte Genauigkeit zu erreichen.\\ 
\\Zuerst kann gezeigt werden, dass der n-te Term unserer Rekursion wie folgt aussieht:
\begin{equation}\label{eq:nthNum}
\frac{1}{2\sqrt{2}}((1+\sqrt{2})^n-(1-\sqrt{2})^n)
\end{equation}
Dann kann unsere Approximation an die Wurzel im n-ten Schritt wie folgt umgeschrieben werden:
\begin{equation}\label{eq:nthNumSqrt}
1+\frac{((1+\sqrt{2})^n-(1-\sqrt{2})^n)}{((1+\sqrt{2})^{n+1})-(1-\sqrt{2})^{n+1})}
\end{equation}
Und wir wollen ein geeignetes minimales $\emph{n}$ finden, damit der Betrag der Differenz aus unserer Konstante und der Approximation (\ref{eq:nthNumSqrt}) ein vorgegebenes $\varepsilon$ nicht überschreitet. Das heißt Folgendes ist erfüllt:
\begin{equation}\label{eq:errAprx}
|\sqrt{2}-1-\frac{((1+\sqrt{2})^n-(1-\sqrt{2})^n)}{((1+\sqrt{2})^{n+1})-(1-\sqrt{2})^{n+1})}|<\varepsilon
\end{equation}
Nach der Umwandlung sollte Folgendes gelten:
\begin{equation*}\label{eq:error2} 
\begin{cases} 
(\sqrt{2}-1)^n\cdot(4-2a+\varepsilon\cdot(a-1)<\varepsilon\cdot(1+\sqrt{2})^{n+1}
\\ (1-\sqrt{2})^n\cdot(4-2a-\varepsilon\cdot(a-1)<\varepsilon\cdot(1+\sqrt{2})^{n+1}
\end{cases}
\end{equation*}
Für ein gerades n ist erfüllt:
\begin{equation}\label{eq:errorLog} 
\begin{cases} 
n>\frac{log_2{(4-2\sqrt{2}-\varepsilon\cdot(\sqrt{2}-1))}-log_2{(1+\sqrt{2})}-log_2{\varepsilon}}{\log_2{(1+\sqrt{2})-\log_2{(\sqrt{2}-1)}}}
\\ n>\frac{log_2{(4-2\sqrt{2}+\varepsilon\cdot(\sqrt{2}-1))}-log_2{(1+\sqrt{2})}-log_2{\varepsilon}}{\log_2{(1+\sqrt{2})-\log_2{(\sqrt{2}-1)}}}
\end{cases}
\end{equation}
Der Nenner kann umgerechnet werden:
\begin{equation}\label{eq:denominator} 
\log_2{(1+\sqrt{2})}-\log_2{(\sqrt{2}-1)}=\log_2{(1+\sqrt{2})^2}=2\cdot\log_2{(1+\sqrt{2})}
\end{equation}
Nach \(\log_2{x}\leq x\) gilt es immer:
\begin{equation*}\label{eq:logx} 
log_2{(4-2\sqrt{2}+\varepsilon\cdot(\sqrt{2}-1))} - log_2{(4-2\sqrt{2})}<\varepsilon\cdot\frac{\sqrt{2}-1}{4-2\sqrt{2}}
\end{equation*}
D.h. es gilt für \(\varepsilon<1\):
\begin{equation}\label{eq:firstNum} 
log_2{(4-2\sqrt{2}+\varepsilon\cdot(\sqrt{2}-1))} < log_2{(4-2\sqrt{2})}+1
\end{equation}
Ähnlich für den zweiten Term:
\begin{equation}\label{eq:secondNum} 
log_2{(4-2\sqrt{2}-\varepsilon\cdot(\sqrt{2}-1))} < log_2{(4-2\sqrt{2})}+1
\end{equation}
Entsprechend erhalten wir aus (\ref{eq:denominator}), (\ref{eq:firstNum}), (\ref{eq:secondNum}) für den gesamten Ausdruck (\ref{eq:errorLog}):
\begin{equation}\label{eq:errorAprx} 
n>\frac{log_2{(4-2\sqrt{2})}-\log_2{\varepsilon}}{2\cdot\log_2{(1+\sqrt{2})}}
\end{equation}
Diese Formel (\ref{eq:errorAprx}) kann durch Schätzungen weiter vereinfacht werden:
\begin{equation*}\label{eq:errorAprxEasy} 
n>1+\frac{1}{2\cdot\log_2{\frac{1}{\varepsilon}}}
\end{equation*}
Und für unsere Bequemlichkeit:
\begin{equation*}
n>1+\frac{1}{2}\cdot\log_2{10}\cdot\log_{10}{\frac{1}{\varepsilon}}
\end{equation*}
\begin{equation*}
\log_2{10}\approx3.3
\end{equation*}
\begin{equation}\label{eq:finalAproximation}
n = \lceil 1+1.65\cdot\log_{10}{\frac{1}{\varepsilon}}\rceil
\end{equation}
Das Schöne an dieser Formel (\ref{eq:finalAproximation}) ist, dass wir den Logarithmus nicht berechnen müssen, weil wir stattdessen gleich die Anzahl der Nachkommastellen einsetzen können.




\section{Performanzanalyse}



\section{Zusammenfassung und Ausblick}

% TODO: Fuegen Sie Ihre Quellen der Datei Ausarbeitung.bib hinzu
% Referenzieren Sie diese dann mit \cite{}.
% Beispiel: CR2 ist ein Register der x86-Architektur~\cite{intel2017man}.
\bibliographystyle{plain}
\bibliography{Ausarbeitung}{}

\end{document}
